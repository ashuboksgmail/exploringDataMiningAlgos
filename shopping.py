# -*- coding: utf-8 -*-
"""shopping.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hu2dXp3mmXl6zQ2BPgmd-MQZLFsxZ4VF
"""

#mounting google driv
from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/DMV



import csv
import numpy as np

# Read in the shoppingtransactions.csv file and convert it to a list of lists
with open('shoppingtransactions.csv', 'r') as f:
    reader = csv.reader(f)
    transactions = list(reader)

# Remove the header row from the transactions list
transactions = transactions[1:]
print (transactions)

# Calculate the support of an item or set of items
def sup(args):
    # Convert the input arguments into a list of items
    items = args.split(',')
    items = [item.strip() for item in items]

    print(items)
    # Count the number of transactions that contain all of the items in the list
    count = 0
    for transaction in transactions:
        if set(items).issubset(set(transaction)):
            count += 1

    # Calculate the support as the count divided by the total number of transactions
    support = count / len(transactions)

    # Print the support as a percentage with two decimal places
    print("{:.2f}%".format(support * 100))


# Calculate the confidence of an item or set of items given another item or set of items
def con(args):
    # Split the input arguments into the antecedent and consequent items
    antecedent, consequent = args.split('-->')

    # Convert the antecedent and consequent into lists of items
    antecedent_items = antecedent.split(',')
    antecedent_items = [item.strip() for item in antecedent_items]
    consequent_items = consequent.split(',')
    consequent_items = [item.strip() for item in consequent_items]

    # Count the number of transactions that contain both the antecedent and consequent items
    both_count = 0
    # Count the number of transactions that contain only the antecedent items
    antecedent_count = 0
    for transaction in transactions:
        if set(antecedent_items).issubset(set(transaction)):
            antecedent_count += 1
            if set(consequent_items).issubset(set(transaction)):
                both_count += 1

    # Calculate the confidence as the ratio of transactions that contain both the antecedent and consequent
    # items to the transactions that contain only the antecedent items
    if antecedent_count == 0:
        print("Antecedent item(s) not found in any transaction.")
    else:
        confidence = both_count / antecedent_count
        # Print the confidence as a percentage with two decimal places
        print("{:.2f}%".format(confidence * 100))


# Prompt the user for input until the user selects Option 3 (exit)
while True:
    print("Select an option:")
    print("1. sup item[,item]")
    print("2. con item[,item] --> item[,item]")
    print("3. exit")
    option = input("> ")

    if option == '1':
        item = input("Enter item or items separated by commas: ")
        sup(item)
    elif option == '2':
        items = input("Enter item(s) for antecedent, then ' --> ', then item(s) for consequent: ")
        con(items)
    elif option == '3':
        break
    else:
        print("Invalid option. Please enter 1, 2, or 3.")